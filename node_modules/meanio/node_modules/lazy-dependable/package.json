{
  "name": "lazy-dependable",
  "version": "0.2.0",
  "description": "Implementation of dependable with lazy dependency resolution",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/andrija-hers/lazy-dependable.git"
  },
  "dependencies": {
    "dependable-list": "latest"
  },
  "keywords": [
    "dependencies",
    "resolving",
    "iterating"
  ],
  "author": {
    "name": "Andrija Petrovic"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/andrija-hers/lazy-dependable/issues"
  },
  "homepage": "https://github.com/andrija-hers/lazy-dependable",
  "readme": "lazy-dependable\n===============\n\nMotivation\n-------------\n\nThis module was built as an in-place replacement for [dependable](https://github.com/idottv/dependable) in order to\n\n1. Introduce \"late resolving\" (I preferred the word 'lazy' over 'late', hence the module name). In other words, once a piece of software asks for a dependency to be resolved, lazy-dependable will not complain if the designated dependency is still not registered.\n2. Introduce more elegant ways for defining dependencies when asking for resolving. The only available mechanism in [dependable](https://github.com/idottv/dependable) is through names of the parameters in the dependency handler. This mechanism is severely sub-optimal, because it asks for stringifying the provided handler in order to parse the very parameter names. Moreover, this mechanism limits the handler programmers. **tldr**: you cannot reuse a single handler for different dependencies, you need to write the same function again, but with different names of input parameters.\n\nUsage\n-----------------\n\n#### Create a Container\nA Container is a single unit of dependency handling. It registers dependencies and resolves them for dependency consumers.\n```javascript\nvar Container = require('lazy-dependable').Container;\n\nvar container = new Container();\ncontainer.register(...\ncontainer.resolve(...\ncontainer.get(...\n//once/if you're done with your container, then don't forget to\ncontainer.destroy();\n```\n\n#### Register a dependency\n```javascript\ncontainer.register('connection',connection);\n```\n`connection` is either an object or a function that will return a connection object.\nYou cannot register functions that will depend on other dependencies - this you can do with [dependable](https://github.com/idottv/dependable)\n\n\n#### Consume dependencies\n##### get\nUse `get` when you need to check if the dependency is registered, because `get` returns immediately.\n```javascript\ncontainer.get('connection',function(connection){\n  if(!connection){\n  }else{\n  }\n});\n```\nIn the above example, if the `get` is called before connection is registered, you will get `undefined`.\n\n##### resolve\nIf you have a function that needs a connection, you\n```javascript\ncontainer.resolve('connection',function(connection){/*use connection*/});\n```\n`resolve` also supports the \"Array notation\":\n```javascript\ncontainer.resolve(['connection',function(connection){/*use connection*/});\n```\nand, of course, the \"dependable notation\":\n```javascript\ncontainer.resolve(function(connection){/*use connection*/});\n```\n**tldr**: if `resolve` gets a function as a first parameter, it will stringify/parse it to read the names of dependables you need.\n\n##### Chain dependency providers\nYou can register functions that will depend on other dependencies and chain dependency providers. For example, if you cannot provide a `database` without obtaining a `configuration` first, you register your `database` provider in the following manner:\n```javascript\ncontainer.register('database',function(configuration){\n  //use the configuration to produce your database connection\n  var database = createDatabase(configuration);\n  //and finally\n  return database;\n});\n```\n\n",
  "readmeFilename": "README.md",
  "_id": "lazy-dependable@0.2.0",
  "_from": "lazy-dependable@latest"
}
